Go on!
03 Jun 2017

Vadim Petrov
Software engineer, Juno
vadim.petrov@gmail.com

* Events aggregator

The microservice must receive events from mobile clients by HTTP, accumulate them in a batch of events and pass it to some 3rd-party system.

.image images/task.png 450 600

* Microservice composition

.image images/schema.png

* Out of the scope

- Kind of processing. It may be any implementation: send to external service, write into file, whatever...
- Processor should take care about errors and possible retry logic.

* Let's write some code

All further code is real and runnable.

You can find it on GitHub.

.link https://github.com/Barberrrry/go-on-presentation

.image images/work.jpg

* Processor

* Fake processor

Create fake processor with random processing time up to 200 ms.

.code examples/service/processor/processor.go

That's enough for processor.

* Collector

* Collector v1: naive plan

- Use a slice as a buffer
- Append incoming data to the buffer
- If buffer size reaches N, flush the buffer to `Processor`

.image images/gopherswim.jpg 300 300

* Collector v1: types and configuration

.code examples/service/collector.v1/collector.go /START1/,/STOP1/

* Collector v1: collect

.code examples/service/collector.v1/collector.go /START2/,/STOP2/

* Collector v1: run

.play examples/run_collector_v1.go /START/,/STOP/

* Collector v1: conclusion

Problems:

- Function `Collect()` waits for `Processor` each N calls
- Collector can work only in a single thread
- Loose the data on process shutdown

Resolution: really bad :(

To be fixed:

- Processing must not block collecting
- Make Collector *concurrent*

* Concurrency

* What is concurrency?

- Concurrency is the composition of independently executing computations.

- Concurrency is a way to design software.

- Concurrency is not parallelism, although it enables parallelism.

- Concurrency is about structure, parallelism is about execution.

- Go has rich support for concurrency using *goroutines* and *channels*.

* Goroutines

Goroutine is an independently executing function, launched by a go statement.

    go func() {
        fmt.Println("Hi!")
    }()

It's very cheap. It's practical to have thousands, even hundreds of thousands of goroutines.

Gouroutine is not OS thread.

* Scheduler

Scheduler runs N contexts. N is configurable.

Each context is running as OS thread.

Each context has own queue of goroutines, but may steal goroutines from other contexts in some cases.

Context stops goroutine execution on any blocking operation (i/o operations, mutexes, waiting for channel etc.) and gets next one from the queue.

* Communication

Multiple goroutines require communication. Goroutine without any input or output is useless.

Don't communicate by sharing memory, share memory by communicating.

* Channels

A channel in Go provides a connection between two goroutines, allowing them to communicate.

A channel is a first-class type.

Channel values may has any type, even other channel.

A channel may be buffered or unbuffered.

* Channel operations

- Create (buffered/unbuffered)
- Read/write
- Iterate through channel until it's closed
- Get length
- Close

* Channel examples

Unbuffered channel

.play examples/channel_unbuffered.go /START/,/STOP/

Buffered channel

.play examples/channel_buffered.go /START/,/STOP/

Iterate through channel

.play examples/channel_range.go /START/,/STOP/

* Channel oops...

Deadlock

.play examples/channel_deadlock.go /START/,/STOP/

Write to closed channel

.play examples/channel_closed.go /START/,/STOP/

.image images/gopherlalala.png 200 200

* Collector v2

* Collector v2: plan

- Run several collector workers
- Use channel to split incoming data among workers
- Each worker has own buffer and flush it when ready

* Collector v2: configuration

Improve configuration and use channel as queue of incoming payloads.

.code examples/service/collector.v2/collector.go /START1/,/STOP1/

* Collector v2: run workers

`Collect()` becomes simple.
But we need to create `Run()` function which will init queue channel and start workers.

.code examples/service/collector.v2/collector.go /START2/,/STOP2/

* Collector v2: worker

Buffer is moved to worker.

.code examples/service/collector.v2/collector.go /START3/,/STOP3/

* Collector v2: run

.play examples/run_collector_v2.go /START/,/STOP/

* Collector v2: conclusion

Fixed:

- Function `Collect()` is not blocked anymore by `Processor`
- Workers are able to call `Processor` concurrently

Problems:

- Buffer is flushed only when reaches max batch size
- Still loose the data on process shutdown

Resolution: better, but still not good

To be fixed:

- Flush buffer after some timeout since last flush

* Select

* Select

The `select` statement waits on multiple communication operations.

A `select` blocks until one of its cases can run, then it executes that case.

It chooses one at random if multiple are ready.

If all cases are not ready, `default` happens.

    values := make(chan int, 10)
    quit := make(chan struct{})

    for {
        select {
        case v := <-values:
            fmt.Println(v)
        case <-quit:
            return
        default:
            time.Sleep(time.Second)
        }
    }

* Collector v3

* Collector v3: plan

- Extend collector configuration to set flush interval
- Force flush after timeout is expired

* Collector v3: configuration

Extend configuration with flush interval.

.code examples/service/collector.v3/collector.go /START1/,/STOP1/

* Collector v3: flush timeout

.code examples/service/collector.v3/collector.go /START2/,/STOP2/

* Collector v3: run

.play examples/run_collector_v3.go /START/,/STOP/

Wait at least 300 ms to be sure all workers flushed buffer by timeout.

* Collector v3: conclusion

Fixed:

- Flush interval does not depend on payloads incoming rate

Problems:

- We didn't loose data only because of 300 ms waiting time before exit, but process may be interrupt at any time.

Resolution: good, but there is still one problem

To be fixed:

- Graceful shutdown

* Collector v4. Final.

* Collector v4: plan

- Use stop channel to shutdown collector
- Close the queue channel to stop collecting payloads
- Stop all workers before exit

.image images/gopherhat.jpg

* Collector v4: wait for workers

Use `sync.WaitGroup` to wait for all workers are stopped.

.code examples/service/collector.v4/collector.go /START3/,/STOP3/

* Collector v4: don't panic

Check whether the collector is working when payload is collected.

It may be done by panic recover.

.code examples/service/collector.v4/collector.go /START2/,/STOP2/

* Collector v4: finally

All data in queue must be passed to `Processor`, so worker must continue until queue channel is closed.

.code examples/service/collector.v4/collector.go /START4/,/STOP4/

* Collector v4: run

.play examples/run_collector_v4.go /START/,/STOP/

* Collector v4: conclusion

Resolution: good enough

.image images/hallelujah.jpg 400 600

* HTTP server

* HTTP handler

Create HTTP handler to get JSON from request body and collect it by collector.

.code examples/service/server/handler.go /START1/,/STOP1/

* Start service

.code examples/service/server/cmd/main.go /START1/,/STOP1/

* Go on!

Let's run our service and see how it works.

.image images/gopherairplane.jpg 350 450

* Conclusions

Goroutines and channels make it easy to express complex operations dealing with

- multiple inputs
- multiple outputs
- timeouts
- failure

And they're fun to use.

* Questions?

Concurrency in Go

.link https://www.golang-book.com/books/intro/10
.link https://golang.org/doc/effective_go.html#concurrency

"Go Concurrency Patterns" by Rob Pike

.link https://www.youtube.com/watch?v=f6kdp27TYZs

"Concurrency is not parallelism" by Rob Pike

.link https://blog.golang.org/concurrency-is-not-parallelism

Slides and code examples are here:

.link https://github.com/Barberrrry/go-on-presentation