Go on!
03 Jun 2017

Vadim Petrov
Software engineer, Juno
vadim.petrov@gmail.com

* Events aggregator

The microservice must receive events from mobile clients by HTTP, accumulate them in a batch of events and pass it to some 3rd-party system.

.image images/task.png 450 600

* Microservice composition

.image images/schema.png

* Out of the scope

- Kind of processing. It may be any implementation: send to external service, write into file, whatever...

- Processor should take care about errors and possible retry logic.

* Let's write some code

All further code is real and runnable.

You can find it on GitHub.

.link https://github.com/Barberrrry/go-on-presentation

.image images/work.jpg

* Processor

* Fake processor

Create fake processor with random processing time up to 200 ms.

.code examples/service/processor/processor.go

That's enough for processor.

* Collector

* Collector v1: naive plan

- Use a slice as a buffer
- Append incoming data to the buffer
- If buffer size reaches N, flush the buffer to `Processor`

.image images/gopherswim.jpg 300 300

* Collector v1: define

.code examples/service/collector.v1/collector.go /START1/,/STOP1/

* Collector v1: collect

.code examples/service/collector.v1/collector.go /START2/,/STOP2/

* Collector v1: run

.play examples/run_collector_v1.go /START/,/STOP/

* Collector v1: conclusion

Problems:

- Function `Collect()` waits for `Processor` each N calls
- `Collector` is not thread-safe

Resolution: really bad :(

To be fixed:

- Processing must not block collecting
- Make `Collector` *concurrent*

* Concurrency

* What is concurrency?

- Concurrency is the composition of independently executing computations.

- Concurrency is a way to design software.

- Concurrency is not parallelism, although it enables parallelism.

- Concurrency is about structure, parallelism is about execution.

Go has rich support for concurrency using *goroutines* and *channels*.

* Goroutines

Goroutine is an independently executing function, launched by a go statement.

    go func() {
        fmt.Println("Hi!")
    }()

It's very cheap.

It's practical to have thousands, even hundreds of thousands of goroutines.

Gouroutine is not OS thread.

* Scheduler

Scheduler runs N contexts. N is configurable.

Each context is running as OS thread.

Each context has own queue of goroutines, but may steal goroutines from other contexts if queue is empty.

Context stops goroutine execution on any blocking operation (i/o operations, mutexes, waiting for channel etc.) and gets next one from the queue.

* Communication

Goroutines without any input or output are useless.

Multiple goroutines require communication.

Don't communicate by sharing memory, share memory by communicating.

Instead of using locks to mediate access to shared data, use *channels* to pass data between goroutines.

* Channels

A channel in Go provides a connection between two goroutines, allowing them to communicate.

A channel is a first-class type.

Channel values may has any type, even other channel.

A channel may be buffered or unbuffered.

* Channel operations

- Create with buffer size
- Read/write
- Iterate through channel until it's closed
- Get length
- Close

* Be careful with channels...

Do not write to closed channel

.play examples/channel_closed.go /START/,/STOP/

.image images/gopherlalala.png 300 300

* Collector v2

* Collector v2: plan

- Run several collector workers
- Use *channel* to split incoming payloads among workers
- Each worker has own buffer and flush it when ready

.image images/gopherworker.jpg 300 250

* Collector v2: collector

Add collector attributes and use channel as queue of incoming payloads.

.code examples/service/collector.v2/collector.go /START1/,/STOP1/

* Collector v2: run workers

`Collect()` becomes simple.
But we need to create `Run()` function which will init queue channel and start workers.

.code examples/service/collector.v2/collector.go /START2/,/STOP2/

* Collector v2: worker

Buffer is a part of worker now.

.code examples/service/collector.v2/collector.go /START3/,/STOP3/

* Collector v2: run

.play examples/run_collector_v2.go /START/,/STOP/

* Collector v2: conclusion

Fixed:

- Function `Collect()` is not blocked anymore by `Processor`
- Workers are *concurrent*

Problems:

- Buffer is flushed only when reaches max batch size

Resolution: better, but still not good

To be fixed:

- Flush buffer after some timeout since last flush

* Select

* Select

The `select` statement waits on multiple communication operations.

A `select` blocks until one of its cases can run, then it executes that case.

It chooses one at random if multiple are ready.

If all cases are not ready, `default` happens.

    values := make(chan int, 10)
    quit := make(chan struct{})

    for {
        select {
        case v := <-values:
            fmt.Println(v)
        case <-quit:
            return
        default:
            time.Sleep(time.Second)
        }
    }

* Collector v3. Final.

* Collector v3: plan

- Add flush interval as collector parameter
- Force flush periodically

.image images/gopherhat.jpg

* Collector v3: collector

Add flush interval as collector parameter.

.code examples/service/collector.v3/collector.go /START1/,/STOP1/

* Collector v3: flush timeout

.code examples/service/collector.v3/collector.go /START2/,/STOP2/

* Collector v3: run

.play examples/run_collector_v3.go /START/,/STOP/

* Collector v3: conclusion

Resolution: good enough

.image images/hallelujah.jpg 400 600

* HTTP server

* HTTP handler

Create HTTP handler to get JSON from request body and collect it by collector.

.code examples/service/server.v3/handler.go /START1/,/STOP1/

* Start server

.code examples/service/server.v3/cmd/main.go /START1/,/STOP1/

* Go on!

Let's run microservice and see how it works.

.image images/gopherairplane.jpg 350 450

* Conclusions

*Goroutines* and *channels* make it easy to express complex operations dealing with

- multiple inputs
- multiple outputs
- timeouts

And they're fun to use.

By the way, there is advanced *Collector* *v4* with graceful shutdown.

* Questions?

This presentation slides and code (including Collector v4) are here:

.link https://github.com/Barberrrry/go-on-presentation

Concurrency in Go

.link https://www.golang-book.com/books/intro/10
.link https://golang.org/doc/effective_go.html#concurrency

"Go Concurrency Patterns" by Rob Pike

.link https://www.youtube.com/watch?v=f6kdp27TYZs

"Concurrency is not parallelism" by Rob Pike

.link https://blog.golang.org/concurrency-is-not-parallelism
